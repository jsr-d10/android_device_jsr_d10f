From 68547762bb22128b916cb0e407590cd1c396e5ea Mon Sep 17 00:00:00 2001
From: S-trace <S-trace@list.ru>
Date: Sun, 17 Jan 2016 08:00:09 +0300
Subject: [PATCH 01/21] [STORAGES] Correctly handle storages configuration

Honor persist.storages.configuration setting
Set datamedia flag based on ro.*.has.usbmsc props
Set datamedia if /data/media/0/TWRP/.twrps config found
(and so don't lock out backups in datamedia with wiped /data/)

Change-Id: I055eda98fa61a7883cb8321bc9de50732cb2999f
---
 data.cpp | 32 +++++++++++++++++++++++++++++++-
 data.hpp |  7 +++++++
 twrp.cpp | 12 ++++++++++++
 3 files changed, 50 insertions(+), 1 deletion(-)

diff --git a/data.cpp b/data.cpp
index 599b5c0d..f8de511f 100644
--- a/data.cpp
+++ b/data.cpp
@@ -587,7 +587,37 @@ void DataManager::SetDefaultValues()
 	mConst.SetValue(TW_HAS_DATA_MEDIA, "1");
 	datamedia = true;
 #else
-	mData.SetValue(TW_HAS_DATA_MEDIA, "0");
+	char sdcc_configuartion[PROPERTY_VALUE_MAX];
+	char usbmsc_present[PROPERTY_VALUE_MAX];
+	char storage_configuration[PROPERTY_VALUE_MAX];
+	property_get("ro.boot.swap_sdcc", sdcc_configuartion, SDCC_CONFIGURATION_REGULAR);
+	property_get("persist.storages.configuration", storage_configuration, STORAGES_CONFIGURATION_CLASSIC);
+	char *storage_property;
+
+	if (strcmp(sdcc_configuartion, SDCC_CONFIGURATION_REGULAR) == 0) {
+		storage_property = "ro.emmc.has.usbmsc";
+	} else {
+		storage_property = "ro.sd.has.usbmsc";
+	}
+	property_get(storage_property , usbmsc_present, "false");
+
+	if (strcmp(usbmsc_present, "false") == 0) {
+		printf("datamedia = true (forced by property %s=%s)\n",
+		       storage_property, usbmsc_present);
+		mConst.SetValue(TW_HAS_DATA_MEDIA, "1");
+		datamedia = true;
+	} else if (strcmp(storage_configuration, STORAGES_CONFIGURATION_DATAMEDIA) == 0) {
+		printf("datamedia = true (forced by property "
+		       "persist.storages.configuration=%s)\n", storage_configuration);
+		mConst.SetValue(TW_HAS_DATA_MEDIA, "1");
+		datamedia = true;
+	} else if (access("/data/media/0/TWRP/.twrps", F_OK) == 0) {
+		printf("RECOVERY_SDCARD_ON_DATA := true (forced by /data/media/0/TWRP/.twrps)\n");
+		mConst.SetValue(TW_HAS_DATA_MEDIA, "1");
+		datamedia = true;
+	} else {
+		mConst.SetValue(TW_HAS_DATA_MEDIA, "0");
+	}
 #endif
 #ifdef TW_NO_BATT_PERCENT
 	printf("TW_NO_BATT_PERCENT := true\n");
diff --git a/data.hpp b/data.hpp
index 790efc99..04003cd7 100644
--- a/data.hpp
+++ b/data.hpp
@@ -23,6 +23,13 @@
 #include <pthread.h>
 #include "infomanager.hpp"
 
+#define STORAGES_CONFIGURATION_CLASSIC   "0"
+#define STORAGES_CONFIGURATION_INVERTED  "1"
+#define STORAGES_CONFIGURATION_DATAMEDIA "2"
+
+#define SDCC_CONFIGURATION_REGULAR  "0"
+#define SDCC_CONFIGURATION_INVERTED "1"
+#define SDCC_CONFIGURATION_ISOLATED "2"
 using namespace std;
 
 class DataManager
diff --git a/twrp.cpp b/twrp.cpp
index 8c2a24f2..bfb4cce4 100644
--- a/twrp.cpp
+++ b/twrp.cpp
@@ -96,6 +96,18 @@ int main(int argc, char **argv) {
 
 #ifdef RECOVERY_SDCARD_ON_DATA
 	datamedia = true;
+#else
+	char usbmsc_present[PROPERTY_VALUE_MAX];
+	char storage_configuration[PROPERTY_VALUE_MAX];
+	property_get("ro.usbmsc.present", usbmsc_present, "true");
+	property_get("persist.storages.configuration", storage_configuration, STORAGES_CONFIGURATION_CLASSIC);
+	if (strncmp(usbmsc_present, "false", PROPERTY_VALUE_MAX) == 0 || strncmp(storage_configuration, STORAGES_CONFIGURATION_DATAMEDIA, PROPERTY_VALUE_MAX) == 0) {
+		printf("datamedia = true (forced by property ro.usbmsc.present=%s and persist.storages.configuration=%s\n", usbmsc_present, storage_configuration);
+		datamedia = true;
+	} else if (access("/data/media/0/TWRP/.twrps", F_OK) == 0) {
+		printf("datamedia = true (forced by /data/media/0/TWRP/.twrps\n");
+		datamedia = true;
+	}
 #endif
 
 	char crash_prop_val[PROPERTY_VALUE_MAX];
-- 
2.14.1

